[
  {
    "acceptance_criteria": "1. Section 10.7 gate aggregates pass/fail status from all sibling beads (bd-2ja, bd-s6y, bd-1ul, bd-1u4, bd-3ex, bd-2pu).\n2. Gate script (scripts/check_section_10_7_gate.py) runs all section verification scripts and produces a unified JSON report.\n3. Gate fails if any sibling bead's verification evidence is missing or shows a failure.\n4. Unit tests cover gate logic: all-pass, single-fail, and missing-evidence scenarios.\n5. Gate produces a section-level summary under artifacts/ with per-bead status, timestamps, and links to individual evidence files.\n6. E2E logging: gate execution emits structured log lines for each sub-check with bead ID, result, and duration.\n7. Gate is idempotent: running it twice in succession with no changes produces identical output.",
    "created_at": "2026-02-20T07:48:25.395020464Z",
    "created_by": "ubuntu",
    "description": "## Why This Exists\n\nThis is the section-wide verification gate for Section 10.7 (Conformance + Verification). Section 10.7 builds the conformance and verification infrastructure that validates all of franken_node's compatibility, trust, and security claims. It covers golden corpus fixtures, trust protocol vectors, fuzz testing, metamorphic testing, verifier CLI conformance, and external reproduction playbooks.\n\nSection 10.7 is the program's credibility layer. Without rigorous conformance testing and external reproduction, franken_node's claims are unverifiable assertions. This section ensures that every claim is backed by reproducible test fixtures, adversarial test results, and independently executable verification playbooks.\n\n## What This Must Do\n\n1. Aggregate verification evidence from all 6 Section 10.7 beads:\n   - bd-2ja: Build compatibility golden corpus and fixture metadata schema\n   - bd-s6y: Adopt canonical trust protocol vectors from 10.13 + 10.14 and enforce release/publication gates\n   - bd-1ul: Add fuzz/adversarial tests for migration and shim logic\n   - bd-1u4: Add metamorphic tests for compatibility invariants\n   - bd-3ex: Add verifier CLI conformance contract tests\n   - bd-2pu: Add external-reproduction playbook and automation scripts\n2. Verify golden corpus coverage: corpus covers all compatibility bands (core, high-value, edge, unsafe).\n3. Verify fuzz testing coverage: fuzz tests exercise migration parser, shim logic, and compatibility evaluation.\n4. Verify external reproduction: playbook can be executed by an independent party with documented success criteria.\n5. Produce deterministic gate verdict.\n\n## Acceptance Criteria\n\n- All 6 section beads must have PASS verdicts.\n- Golden corpus covers all defined compatibility bands with documented fixture metadata.\n- Fuzz tests have run for minimum configured duration without crashes.\n- Metamorphic tests cover all defined compatibility invariants.\n- External reproduction playbook is self-contained and executable without franken_node team assistance.\n- Gate verdict is deterministic and machine-readable.\n\n## Testing & Logging Requirements\n\n- Gate self-test with mock evidence.\n- Structured logs: GATE_10_7_EVALUATION_STARTED, GATE_10_7_BEAD_CHECKED, GATE_10_7_CORPUS_COVERAGE, GATE_10_7_VERDICT_EMITTED.\n\n## Expected Artifacts\n\n- `scripts/check_section_10_7_gate.py` — gate script with `--json` and `self_test()`\n- `tests/test_check_section_10_7_gate.py` — unit tests\n- `artifacts/section_10_7/bd-1rwq/verification_evidence.json`\n- `artifacts/section_10_7/bd-1rwq/verification_summary.md`\n\n## Dependencies\n\n- Blocked by: bd-2ja, bd-s6y, bd-1ul, bd-1u4, bd-3ex, bd-2pu, bd-1dpd, bd-2twu\n- Blocks: bd-2j9w (program-wide gate), bd-3rc (plan tracker)",
    "id": "bd-1rwq",
    "issue_type": "task",
    "priority": 1,
    "status": "open",
    "title": "[10.7] Section-wide verification gate: comprehensive unit+e2e+logging",
    "updated_at": "2026-02-20T17:24:48.903407360Z"
  },
  {
    "created_at": "2026-02-20T07:36:40.869070676Z",
    "created_by": "ubuntu",
    "description": "Section: 10.8 — Operational Readiness\n\nStrategic Context:\nOperational readiness and fleet safety posture: control APIs, observability contracts, safe-mode operations, and disaster drills.\n\nExecution Requirements:\n- Preserve all scoped capabilities from the canonical plan.\n- Keep contracts self-contained so future contributors can execute without reopening the master plan.\n- Require explicit testing strategy (unit + integration/e2e) and structured logging/telemetry for every child bead.\n- Require artifact-backed validation for performance, security, and correctness claims.\n\nDependency Semantics:\n- This epic is blocked by its child implementation beads.\n- Cross-epic dependencies encode strategic sequencing and canonical ownership boundaries.\n\n## Success Criteria\n- All child beads for this section are completed with acceptance artifacts attached and no unresolved blockers.\n- Section-level verification gate for comprehensive unit tests, integration/e2e workflows, and detailed structured logging evidence is green.\n- Scope-to-plan traceability is explicit, with no feature loss versus the canonical plan section.\n\n## Optimization Notes\n- User-Outcome Lens: \"[PLAN 10.8] Operational Readiness\" must improve operator confidence, safety posture, and deterministic recovery behavior under both normal and adversarial conditions.\n- Cross-Section Coordination: child beads must encode integration assumptions explicitly to avoid local optimizations that degrade system-wide correctness.\n- Verification Non-Negotiable: completion requires reproducible unit/integration/E2E evidence and structured logs suitable for independent replay.\n- Scope Protection: any simplification must preserve canonical-plan feature intent and be justified with explicit tradeoff documentation.",
    "id": "bd-c4f",
    "issue_type": "epic",
    "notes": "Acceptance Criteria alias (plan-space normalization, 2026-02-20):\n- The `Success Criteria` section in this bead is the canonical acceptance contract for closure.\n- Closure additionally requires linked unit/integration/E2E verification evidence and detailed structured logging artifacts from all child implementation beads.",
    "priority": 2,
    "status": "open",
    "title": "[PLAN 10.8] Operational Readiness",
    "updated_at": "2026-02-20T17:13:43.332719940Z"
  },
  {
    "acceptance_criteria": "AC for bd-7om:\n1. All product services adopt the canonical three-phase cancellation protocol from 10.15: Cancel (signal intent) -> Drain (complete in-flight work, reject new work) -> Finalize (release resources, emit completion evidence).\n2. A CancellationProtocol trait is defined with methods: cancel(), drain(timeout: Duration) -> DrainOutcome, finalize() -> FinalizeReport.\n3. State transitions are strictly ordered: Idle -> Cancelled -> Draining -> Finalized. Any out-of-order transition attempt returns Err with stable code CANCEL_PROTOCOL_VIOLATION.\n4. Drain has a configurable timeout; if in-flight work does not complete within the timeout, drain returns DrainOutcome::TimedOut with a list of still-active work items, and finalize force-drops them with a CANCEL_FORCE_DROP log event.\n5. Double-cancel is idempotent (no error, no state change beyond first cancel).\n6. Every service implementing CancellationProtocol emits structured telemetry: CANCEL_SIGNAL_RECEIVED, DRAIN_STARTED, DRAIN_COMPLETED / DRAIN_TIMED_OUT, FINALIZE_COMPLETED with trace correlation IDs and elapsed-time measurements.\n7. Unit tests verify: (a) happy-path cancel -> drain -> finalize completes cleanly, (b) drain timeout triggers forced finalization, (c) out-of-order transition is rejected, (d) double-cancel is idempotent, (e) new work submitted during drain phase is rejected with WORK_REJECTED_DRAINING.\n8. Integration test: a multi-service orchestration cancels all services concurrently and verifies total drain time is bounded by the maximum individual drain timeout (parallel drain, not serial).",
    "assignee": "CrimsonCrane",
    "created_at": "2026-02-20T07:36:49.901866673Z",
    "created_by": "ubuntu",
    "description": "Master Plan Source: PLAN_TO_CREATE_FRANKEN_NODE.md — Section 10.11 (FrankenSQLite-Inspired Runtime Systems), cross-ref Section 9G.2, 9J.19\n\n## Why This Exists\n\nEvery long-running product operation in franken_node — migration orchestration, anti-entropy sweeps, trust rotation, bulk replication, rollout state transitions — must be cancellable in a disciplined manner. The naive approach (drop the future / kill the task) leaves resources leaked, obligations unfulfilled, and partial state scattered across services. Enhancement Map 9G.2 mandates cancellation as a strict protocol for all long-running orchestration tasks, implemented as a three-phase sequence: cancel (signal intent to stop), drain (complete in-flight sub-operations, flush buffers, release held resources), and finalize (produce a terminal status record and obligation closure proof). 9J.19 extends this with cancellation-complete protocol discipline, requiring that every cancellation produces a proof that all obligations spawned by the cancelled operation have been accounted for.\n\nThis bead adopts the canonical cancel-drain-finalize protocol from 10.15 (bd-1cs7) into franken_node's product service layer, providing a `CancellableTask` trait and runtime support that ensures every product service's long-running operations implement the full three-phase cancellation protocol.\n\n## What This Must Do\n\n1. Define a `CancellableTask` trait with three required methods: `on_cancel(&mut self)` (enter drain phase), `on_drain_complete(&mut self) -> DrainResult` (signal drain completion with status), and `on_finalize(&mut self) -> FinalizeRecord` (produce terminal status and obligation closure proof).\n2. Implement a `CancellationRuntime` that manages the lifecycle of cancellable tasks: accepts cancel signals, enforces drain timeout, and calls finalize regardless of drain outcome.\n3. Enforce drain timeout: if `on_drain_complete` is not signalled within a configurable deadline after `on_cancel`, the runtime force-transitions to finalize with a `DrainTimeout` status, ensuring the system never hangs waiting for a stalled drain.\n4. Produce obligation closure proofs on finalize: the `FinalizeRecord` must enumerate every obligation spawned by the task and its terminal state (fulfilled, compensated, or force-closed).\n5. Integrate with the scheduler lane system (bd-lus): cancellation of a task immediately releases its lane slot and bulkhead permit during the cancel phase (not deferred to finalize).\n6. Ensure `CancellableTask` implementations are verified at registration time: a task that does not implement all three methods is rejected with a clear diagnostic.\n\n## Context from Enhancement Maps\n\n- 9G.2: \"Cancellation as a strict protocol for all long-running orchestration tasks\"\n- 9J.19: \"Cancellation-complete protocol discipline with obligation closure proofs\"\n- Architecture invariant #3 (8.5): Cancellation protocol semantics — cancellation is a first-class protocol, not an afterthought.\n- Architecture invariant #4 (8.5): Two-phase effects — drain phase must complete two-phase effects before finalize.\n- Architecture invariant #8 (8.5): Evidence-by-default — finalize records are evidence and must be persisted.\n\n## Dependencies\n\n- Upstream: bd-1cs7 (10.15 cancel-drain-finalize protocol implementation), bd-1n5p (10.15 obligation-tracked channels — for obligation closure proof generation)\n- Downstream: bd-lus (scheduler lanes release slots on cancel), bd-2ah (obligation channels integrate with cancellation for closure proofs), bd-24k (bounded masking defers cancel signals), bd-390 (anti-entropy reconciliation is cancellable), bd-3hw (saga orchestrator cancellation triggers compensation), bd-93k (checkpoint placement is cancel-aware), bd-1jpo (10.11 section-wide verification gate)\n\n## Acceptance Criteria\n\n1. Every long-running product operation (migration, anti-entropy, trust rotation, rollout, replication) implements `CancellableTask` — verified by startup-time registration check.\n2. Cancel signal transitions a running task to drain phase within 1 event-loop tick; the task's lane slot is released immediately.\n3. Drain timeout enforcement: a task whose drain exceeds the configured deadline (default 5 seconds) is force-transitioned to finalize with `DrainTimeout` status.\n4. `FinalizeRecord` includes: task_id, cancel_reason, drain_status (completed/timed_out), obligation_closure_proof (list of obligation IDs and terminal states), and wall-clock timestamps for each phase transition.\n5. Obligation closure proof is complete: every obligation spawned by the task appears in the proof with a terminal state. A missing obligation causes a `ClosureProofIncomplete` alert.\n6. A task that is not cancelled completes normally and produces a `FinalizeRecord` with `cancel_reason: None` (the protocol applies to all task completions, not just cancellations).\n7. Nested cancellation: a parent task cancellation propagates to child tasks, and the parent's finalize waits for all children's finalize records.\n8. Verification evidence JSON includes tasks_cancelled, tasks_drain_completed, tasks_drain_timed_out, closure_proofs_generated, closure_proofs_complete, and avg_drain_duration_ms fields.\n\n## Testing & Logging Requirements\n\n- Unit tests: (a) CancellableTask lifecycle: create -> run -> cancel -> drain -> finalize; (b) Drain timeout enforcement; (c) FinalizeRecord completeness; (d) Lane slot release timing on cancel; (e) Normal completion (no cancel) still produces FinalizeRecord.\n- Integration tests: (a) Migration orchestration cancel mid-flight with obligation closure; (b) Anti-entropy sweep cancel with partial progress safely abandoned; (c) Nested task cancellation propagation (parent -> 3 children); (d) Cancel during two-phase flow prepare — verify rollback and closure proof.\n- Adversarial tests: (a) Drain handler that panics — verify finalize still executes with error status; (b) Cancel signal sent to already-finalizing task — verify idempotent handling; (c) 100 concurrent cancellations — verify no resource leaks; (d) Cancel with no obligations — verify empty but valid closure proof.\n- Structured logs: Events use stable codes (FN-CX-001 through FN-CX-010), include `task_id`, `trace_id`, `phase` (cancel/drain/finalize), `drain_status`, `obligations_count`. JSON-formatted.\n\n## Expected Artifacts\n\n- docs/specs/section_10_11/bd-7om_contract.md\n- crates/franken-node/src/runtime/cancellation.rs (or equivalent module path)\n- crates/franken-node/src/runtime/cancellable_task.rs (trait definition + registration)\n- scripts/check_cancellation_protocol.py (with --json flag and self_test())\n- tests/test_check_cancellation_protocol.py\n- artifacts/section_10_11/bd-7om/verification_evidence.json\n- artifacts/section_10_11/bd-7om/verification_summary.md",
    "id": "bd-7om",
    "issue_type": "task",
    "notes": "Plan-space QA addendum (2026-02-20):\n1) Preserve full canonical-plan scope; no feature compression or silent omission is allowed.\n2) Completion requires comprehensive verification coverage appropriate to scope: unit tests, integration tests, and E2E scripts/workflows with detailed structured logging (stable event/error codes + trace correlation IDs).\n3) Completion requires reproducible evidence artifacts (machine-readable + human-readable) that allow independent replay and root-cause triage.\n4) Any implementation PR for this bead must include explicit links to the above test/logging artifacts.",
    "priority": 2,
    "status": "open",
    "title": "[10.11] Adopt canonical cancel -> drain -> finalize protocol contracts (from `10.15`) for product services.",
    "updated_at": "2026-02-22T02:59:19.266537412Z"
  },
  {
    "acceptance_criteria": "AC for bd-2ah:\n1. All critical flows adopt obligation-tracked two-phase channels from 10.15: Phase 1 (Prepare) reserves resources and returns an ObligationToken; Phase 2 (Commit/Rollback) consumes the token to finalize or release.\n2. An ObligationToken is a linear type (must be consumed exactly once); dropping an unconsumed token triggers a LEAKED_OBLIGATION panic in debug mode and a structured error log + forced rollback in release mode.\n3. The ObligationChannel<T> type enforces the two-phase contract: prepare(payload) -> Result<ObligationToken>, commit(token) -> Result<T>, rollback(token) -> Result<()>.\n4. Obligation tokens carry a monotonic sequence number and creation timestamp; tokens from a previous epoch (see bd-2gr) are automatically rejected with STALE_OBLIGATION_EPOCH.\n5. A configurable obligation timeout ensures that prepare-without-commit/rollback is detected: if a token is neither committed nor rolled back within the timeout, a background reaper logs OBLIGATION_TIMEOUT and forces rollback.\n6. The channel tracks outstanding obligation count as a gauge metric; the gauge must return to zero after all flows complete (verified in integration tests).\n7. Unit tests verify: (a) prepare -> commit round-trip succeeds, (b) prepare -> rollback releases resources, (c) dropped token triggers leak detection, (d) stale-epoch token is rejected, (e) timeout triggers forced rollback, (f) double-commit on same token returns OBLIGATION_ALREADY_CONSUMED.\n8. Structured log events: OBLIGATION_PREPARE / OBLIGATION_COMMIT / OBLIGATION_ROLLBACK / OBLIGATION_TIMEOUT / LEAKED_OBLIGATION with channel name, sequence number, and trace correlation ID.",
    "assignee": "CrimsonCrane",
    "created_at": "2026-02-20T07:36:50.060962999Z",
    "created_by": "ubuntu",
    "description": "Master Plan Source: PLAN_TO_CREATE_FRANKEN_NODE.md — Section 10.11 (FrankenSQLite-Inspired Runtime Systems), cross-ref Section 9G.3, 9J.19\n\n## Why This Exists\n\nCritical product flows in franken_node — publish-then-promote, rollback-then-notify, migration-commit-then-cleanup — require atomicity guarantees that simple fire-and-forget messaging cannot provide. If the publish succeeds but the promote notification is lost, the system enters an inconsistent state where a trust artifact is stored but not visible. Enhancement Map 9G.3 mandates obligation-tracked two-phase workflows for critical publish/rollback paths, where each message in a workflow carries a tracked obligation that must be explicitly fulfilled or compensated, and the system can audit at any time which obligations are outstanding. 9J.19 extends this with cancellation-complete protocol discipline, requiring that even cancelled workflows produce obligation closure proofs demonstrating that no obligations were silently dropped.\n\nThis bead adopts the canonical obligation-tracked two-phase channel contracts from 10.15 (bd-1n5p obligation channels) into franken_node's product service layer, replacing ad hoc messaging in critical flows with channels where every sent message creates a tracked obligation, the receiver must acknowledge or reject, and the system maintains an obligation ledger for auditability.\n\n## What This Must Do\n\n1. Implement an `ObligationChannel<T>` abstraction that wraps inter-service communication for critical flows, where every `send()` creates a tracked obligation with a unique obligation ID, deadline, and originating trace context.\n2. The receiver must explicitly `fulfill(obligation_id)` or `reject(obligation_id, reason)` — if neither occurs before the deadline, the channel emits an `ObligationTimeout` event and triggers the configured timeout policy (retry, compensate, or escalate).\n3. Maintain an `ObligationLedger` that tracks all outstanding obligations, their creation time, deadline, and current status — queryable for operational dashboards and audit.\n4. On cancellation of a workflow that has outstanding obligations, produce an obligation closure proof: a signed record listing each obligation and its terminal state (fulfilled, rejected, compensated, or cancelled-with-reason).\n5. Integrate with the append-only decision stream (per 9G.9): all obligation state transitions (created, fulfilled, rejected, timed-out, cancelled) are recorded as immutable events.\n6. Provide a `TwoPhaseFlow` builder that composes obligation channels into multi-step workflows with explicit prepare and commit phases, where prepare can be rolled back atomically.\n\n## Context from Enhancement Maps\n\n- 9G.3: \"Obligation-tracked two-phase workflows for critical publish/rollback paths\"\n- 9J.19: \"Cancellation-complete protocol discipline with obligation closure proofs\"\n- Architecture invariant #4 (8.5): Two-phase effects — critical state changes must go through prepare/commit.\n- Architecture invariant #3 (8.5): Cancellation protocol semantics — cancelled workflows must produce closure proofs.\n- Architecture invariant #8 (8.5): Evidence-by-default — obligation state transitions are evidence and must be recorded.\n\n## Dependencies\n\n- Upstream: bd-1n5p (10.15 obligation-tracked two-phase channels), bd-7om (cancel-drain-finalize protocol for cancellation integration), bd-126h (10.14 append-only marker stream for decision stream recording)\n- Downstream: bd-390 (anti-entropy reconciliation applies records through obligation channels), bd-3hw (saga orchestrator composes with obligation channels), bd-93k (checkpoint placement integrates with obligation tracking), bd-1jpo (10.11 section-wide verification gate)\n\n## Acceptance Criteria\n\n1. Every critical flow (publish-promote, rollback-notify, migration-commit-cleanup) uses `ObligationChannel` instead of direct messaging — verified by code audit gate.\n2. An unfulfilled obligation triggers `ObligationTimeout` event within 1 second of the deadline, with the configured policy (retry/compensate/escalate) executing automatically.\n3. The `ObligationLedger` correctly reports all outstanding obligations with creation time, deadline, and status — verified by querying during a multi-step workflow.\n4. Cancellation of a workflow with 3 outstanding obligations produces a closure proof listing all 3 obligations and their terminal states.\n5. Obligation closure proofs are signed and verifiable; a tampered proof fails verification.\n6. All obligation state transitions appear in the append-only decision stream in causal order.\n7. `TwoPhaseFlow` builder: a prepare phase that succeeds followed by a commit phase that fails triggers automatic rollback of the prepare, verified end-to-end.\n8. Verification evidence JSON includes obligations_created, obligations_fulfilled, obligations_timed_out, obligations_cancelled, closure_proofs_generated, and ledger_query_latency_ms fields.\n\n## Testing & Logging Requirements\n\n- Unit tests: (a) ObligationChannel send creates obligation with correct ID and deadline; (b) fulfill() transitions obligation to fulfilled state; (c) reject() transitions to rejected state; (d) Timeout fires at deadline; (e) Closure proof includes all obligations from a cancelled workflow.\n- Integration tests: (a) Full publish-promote flow through obligation channels with success path; (b) Publish-promote with promote failure triggering compensation; (c) Multi-step TwoPhaseFlow with rollback on commit failure; (d) Obligation ledger query during active workflow returns correct state.\n- Adversarial tests: (a) Double-fulfill of the same obligation — verify idempotent acceptance or rejection; (b) Fulfill after deadline — verify late fulfillment is recorded but does not suppress the timeout event; (c) Cancellation during the prepare phase of a TwoPhaseFlow — verify rollback and closure proof; (d) Obligation ledger under high concurrency (1000 concurrent obligations) — verify no lost obligations.\n- Structured logs: Events use stable codes (FN-OB-001 through FN-OB-012), include `obligation_id`, `trace_id`, `deadline`, `status`, `workflow_id`. JSON-formatted.\n\n## Expected Artifacts\n\n- docs/specs/section_10_11/bd-2ah_contract.md\n- crates/franken-node/src/runtime/obligation_channel.rs (or equivalent module path)\n- crates/franken-node/src/runtime/obligation_ledger.rs\n- crates/franken-node/src/runtime/two_phase_flow.rs\n- scripts/check_obligation_channels.py (with --json flag and self_test())\n- tests/test_check_obligation_channels.py\n- artifacts/section_10_11/bd-2ah/verification_evidence.json\n- artifacts/section_10_11/bd-2ah/verification_summary.md",
    "id": "bd-2ah",
    "issue_type": "task",
    "priority": 2,
    "status": "open",
    "title": "[10.11] Adopt canonical obligation-tracked two-phase channel contracts (from `10.15`) for critical flows.",
    "updated_at": "2026-02-22T02:59:22.274829053Z"
  }
]
