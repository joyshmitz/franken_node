[
  {
    "assignee": "PurpleHarbor",
    "created_at": "2026-02-20T07:36:41.031586341Z",
    "created_by": "ubuntu",
    "description": "Section: 10.10 — FCP-Inspired Hardening + Interop Integration Track\n\nStrategic Context:\nFCP-inspired hardening/interop contract for IDs, serialization, control-channel auth, revocation freshness, and publication gating.\n\nExecution Requirements:\n- Preserve all scoped capabilities from the canonical plan.\n- Keep contracts self-contained so future contributors can execute without reopening the master plan.\n- Require explicit testing strategy (unit + integration/e2e) and structured logging/telemetry for every child bead.\n- Require artifact-backed validation for performance, security, and correctness claims.\n\nDependency Semantics:\n- This epic is blocked by its child implementation beads.\n- Cross-epic dependencies encode strategic sequencing and canonical ownership boundaries.\n\n## Success Criteria\n- All child beads for this section are completed with acceptance artifacts attached and no unresolved blockers.\n- Section-level verification gate for comprehensive unit tests, integration/e2e workflows, and detailed structured logging evidence is green.\n- Scope-to-plan traceability is explicit, with no feature loss versus the canonical plan section.\n\n## Optimization Notes\n- User-Outcome Lens: \"[PLAN 10.10] FCP-Inspired Hardening + Interop Integration Track\" must improve operator confidence, safety posture, and deterministic recovery behavior under both normal and adversarial conditions.\n- Cross-Section Coordination: child beads must encode integration assumptions explicitly to avoid local optimizations that degrade system-wide correctness.\n- Verification Non-Negotiable: completion requires reproducible unit/integration/E2E evidence and structured logs suitable for independent replay.\n- Scope Protection: any simplification must preserve canonical-plan feature intent and be justified with explicit tradeoff documentation.",
    "id": "bd-1hf",
    "issue_type": "epic",
    "notes": "Claimed ready open integration epic; validating closed child set + section gate and producing closure evidence",
    "priority": 2,
    "status": "in_progress",
    "title": "[PLAN 10.10] FCP-Inspired Hardening + Interop Integration Track",
    "updated_at": "2026-02-22T02:56:23.034356990Z"
  },
  {
    "acceptance_criteria": "1. All canonical trust protocol vectors from 10.13 (golden vectors, interop suites, fuzz corpus) and 10.14 are imported into the release verification pipeline.\n2. Release gate: CI blocks release if any canonical vector fails verification — no override without explicit exception.\n3. Publication gate: documentation or artifact publication is blocked if associated trust vectors have not passed in the current build.\n4. Vector adoption is traceable: each imported vector references its source bead ID and version.\n5. Gate produces a structured JSON report listing each vector set, its pass/fail status, and the timestamp of last verification.\n6. New vectors added in 10.13/10.14 are automatically picked up by the gate without manual integration (convention-based discovery).\n7. Per Section 3.2 capability #7 (compatibility lockstep oracle): vectors include cross-runtime comparison results where applicable.",
    "assignee": "CrimsonCrane",
    "created_at": "2026-02-20T07:36:47.344215304Z",
    "created_by": "ubuntu",
    "description": "## [10.7] Adopt Canonical Trust Protocol Vectors and Enforce Release Gates\n\n### Why This Exists\n\nSections 9E.10 and 9I.20 require \"CDDL-like schema + golden vectors for cross-impl parity.\" The 10.13 and 10.14 tracks have produced golden test vectors — `fnode_trust_vectors_v1.json`, interop fixtures, idempotency vectors, epoch key vectors, seed derivation vectors, and MMR proof vectors — that define the canonical behavior of franken_node's trust protocol. These vectors must be promoted from development-time test assets to mandatory release gates. No release may ship if any canonical vector fails. This ensures cross-implementation parity and prevents protocol drift between releases.\n\n### What It Must Do\n\n**Vector adoption**: Collect all golden vectors from 10.13 (`vectors/fnode_trust_vectors_v1.json`, `fixtures/interop/`) and 10.14 (idempotency vectors, epoch key vectors, seed derivation vectors, MMR proof vectors) into a canonical vector registry. The registry is a manifest file (`vectors/canonical_manifest.toml`) that lists every vector suite, its source, its schema version, and its required-pass status.\n\n**Release gate enforcement**: A CI gate runs all canonical vector suites before any release. The gate loads the manifest, executes each suite, and blocks the release if any required suite fails. The gate produces structured JSON output listing each suite's name, vector count, pass count, fail count, and overall status.\n\n**Vector change control**: Modifications to any canonical vector file require an explicit changelog entry in `vectors/CHANGELOG.md` documenting what changed, why, and which implementations are affected. A pre-commit hook or CI check enforces that vector file changes are accompanied by changelog entries.\n\n**Schema validation**: Each vector file must conform to its declared schema (JSON Schema or CDDL-derived). The gate validates schema conformance before executing vectors, so malformed vectors are caught early with clear error messages rather than producing confusing runtime failures.\n\n**Cross-implementation parity check**: Where multiple implementations exist (Node shim, Bun shim, native franken_node), the gate runs vectors against all available implementations and reports any divergence. Divergence on a required vector is a release blocker.\n\n### Acceptance Criteria\n\n1. A canonical vector manifest (`vectors/canonical_manifest.toml`) lists all vector suites with source path, schema version, and required-pass status.\n2. CI release gate executes all suites listed in the manifest and blocks release on any required-suite failure.\n3. Gate output is structured JSON: suite name, vector count, pass/fail counts, overall status, execution time.\n4. Modifications to canonical vector files require a corresponding entry in `vectors/CHANGELOG.md`; CI enforces this.\n5. Schema validation runs before vector execution; malformed vectors produce clear error messages identifying the schema violation.\n6. Cross-implementation parity is checked where multiple implementations are available; divergence on required vectors blocks release.\n7. Verification script `scripts/check_canonical_vectors.py` with `--json` flag validates the full vector pipeline.\n8. Unit tests in `tests/test_check_canonical_vectors.py` cover manifest parsing, schema validation, changelog enforcement, parity checking, and gate pass/fail logic.\n\n### Key Dependencies\n\n- Golden vectors from 10.13 (fnode_trust_vectors_v1.json, interop fixtures).\n- Vectors from 10.14 (idempotency, epoch key, seed derivation, MMR proof).\n- Lockstep harness from 10.2 (for cross-implementation execution).\n- JSON Schema or CDDL schema definitions for each vector format.\n\n### Testing & Logging Requirements\n\n- Gate pass test: run with all vectors passing, assert gate passes and structured output is correct.\n- Gate fail test: inject a failing vector, assert gate blocks with clear identification of the failure.\n- Changelog enforcement test: modify a vector file without changelog, assert CI rejects.\n- Schema validation test: inject a malformed vector, assert schema error is reported before execution.\n- Structured JSON logs for each suite execution: suite name, vectors tested, pass/fail, duration.\n\n### Expected Artifacts\n\n- `vectors/canonical_manifest.toml` — vector registry.\n- `vectors/CHANGELOG.md` — vector change log.\n- `scripts/check_canonical_vectors.py` — verification script.\n- `tests/test_check_canonical_vectors.py` — unit tests.\n- `artifacts/section_10_7/bd-s6y/verification_evidence.json` — gate results.\n- `artifacts/section_10_7/bd-s6y/verification_summary.md` — human-readable summary.\n\n### Additional E2E Requirement\n\n- E2E test scripts must execute full end-to-end workflows from clean fixtures, emit deterministic machine-readable pass/fail evidence, and capture stepwise structured logs for root-cause triage.",
    "id": "bd-s6y",
    "issue_type": "task",
    "priority": 2,
    "status": "in_progress",
    "title": "[10.7] Adopt canonical trust protocol vectors from `10.13` + `10.14` and enforce release/publication gates on those vectors.",
    "updated_at": "2026-02-22T02:54:14.436006439Z"
  },
  {
    "acceptance_criteria": "1. Verifier CLI exposes at least: verify-module, verify-migration, verify-compatibility, and verify-corpus subcommands.\n2. Each subcommand has a conformance contract defined in a spec document under docs/specs/ specifying inputs, outputs, exit codes, and error formats.\n3. Contract tests exercise every specified input/output combination including edge cases and error paths.\n4. Tests validate that CLI output conforms to the documented JSON schema (no undocumented fields, no missing required fields).\n5. Exit codes follow a documented taxonomy: 0=pass, 1=fail, 2=error, 3=skipped.\n6. Per Section 3.2 capability #10 (public verifier toolkit): CLI is usable by an external party with no internal knowledge — contract tests verify this by running in an isolated environment with no access to internal state.\n7. Contract tests are generated from the spec documents (not hand-written) to ensure spec and tests stay in sync.",
    "assignee": "CrimsonCrane",
    "created_at": "2026-02-20T07:36:47.589413741Z",
    "created_by": "ubuntu",
    "description": "## [10.7] Verifier CLI Conformance Contract Tests\n\n### Why This Exists\n\nThe verifier CLI (`franken-node verify`) is a public interface used by external verifiers, CI pipelines, and the verifier economy (10.17, 10.12). Its behavior must be stable and predictable across versions — breaking changes to input formats, output schemas, exit codes, or error messages would break downstream consumers silently. This bead establishes contract tests that pin the CLI's observable behavior, detect unintended breaking changes, and require explicit version bumps when intentional breaking changes are made.\n\n### What It Must Do\n\n**Contract definition**: Define the verifier CLI's contract in a machine-readable format (`spec/verifier_cli_contract.toml` or similar). The contract specifies: (1) accepted input formats (file paths, stdin, glob patterns), (2) output JSON schema for success and error cases, (3) exit codes and their meanings (0 = all checks pass, 1 = some checks fail, 2 = invalid input, 3 = internal error), (4) error message format (structured JSON with error code, human message, and remediation hint), and (5) command-line flag inventory with types and defaults.\n\n**Contract test suite**: A test suite that exercises every aspect of the contract with specific, pinned inputs and expected outputs. Tests use snapshot-style assertions — the expected output is stored alongside the test and compared byte-for-byte (after normalization of timestamps and paths). Adding a new flag or output field is non-breaking; removing or changing one is breaking.\n\n**Breaking change detection**: When a contract test fails, the failure message clearly distinguishes between \"new field added\" (non-breaking, auto-update snapshot) and \"existing field changed/removed\" (breaking, requires version bump). A `--update-snapshots` flag regenerates expected outputs for non-breaking changes.\n\n**Version enforcement**: The CLI embeds a contract version (semver). Breaking changes increment the major version. The contract test suite validates that the embedded version matches the contract definition's version. If a breaking change is detected without a version bump, the gate fails.\n\n**Backward compatibility layer**: When a major version bump occurs, the CLI supports `--compat-version=<N>` to produce output in the previous format for one major version back, giving consumers time to migrate.\n\n### Acceptance Criteria\n\n1. Verifier CLI contract is defined in a machine-readable file specifying input formats, output schemas, exit codes, error formats, and flag inventory.\n2. Contract test suite covers every exit code, every output field, every error code, and every accepted input format with pinned expected outputs.\n3. Breaking vs. non-breaking change detection works: new fields pass, changed/removed fields fail with clear breaking-change message.\n4. Contract version is embedded in CLI output and validated against the contract definition.\n5. `--update-snapshots` regenerates expected outputs for non-breaking changes only.\n6. `--compat-version=<N>` produces output in the previous major version's format.\n7. Verification script `scripts/check_verifier_contract.py` with `--json` flag validates the contract test suite.\n8. Unit tests in `tests/test_check_verifier_contract.py` cover contract parsing, snapshot comparison, breaking change detection, version validation, and compat-version output.\n\n### Key Dependencies\n\n- Verifier CLI implementation (`franken-node verify` subcommand).\n- CLI framework from bd-n9r (cli.rs).\n- JSON Schema for output validation.\n- Existing verification scripts that the CLI orchestrates.\n\n### Testing & Logging Requirements\n\n- Stability test: run contract tests against current CLI, assert all pass.\n- Breaking change test: modify an output field, run tests, assert breaking-change failure.\n- Non-breaking change test: add a new output field, run tests, assert pass (or auto-update).\n- Compat-version test: request previous version output, assert format matches previous contract.\n- Structured JSON logs for each contract test execution: test name, expected vs. actual, pass/fail, breaking/non-breaking classification.\n\n### Expected Artifacts\n\n- `spec/verifier_cli_contract.toml` — contract definition.\n- `tests/contract/snapshots/` — pinned expected outputs.\n- `scripts/check_verifier_contract.py` — verification script.\n- `tests/test_check_verifier_contract.py` — unit tests.\n- `artifacts/section_10_7/bd-3ex/verification_evidence.json` — gate results.\n- `artifacts/section_10_7/bd-3ex/verification_summary.md` — human-readable summary.\n\n### Additional E2E Requirement\n\n- E2E test scripts must execute full end-to-end workflows from clean fixtures, emit deterministic machine-readable pass/fail evidence, and capture stepwise structured logs for root-cause triage.",
    "id": "bd-3ex",
    "issue_type": "task",
    "priority": 2,
    "status": "in_progress",
    "title": "[10.7] Add verifier CLI conformance contract tests.",
    "updated_at": "2026-02-22T02:54:18.008369646Z"
  },
  {
    "acceptance_criteria": "AC for bd-7om:\n1. All product services adopt the canonical three-phase cancellation protocol from 10.15: Cancel (signal intent) -> Drain (complete in-flight work, reject new work) -> Finalize (release resources, emit completion evidence).\n2. A CancellationProtocol trait is defined with methods: cancel(), drain(timeout: Duration) -> DrainOutcome, finalize() -> FinalizeReport.\n3. State transitions are strictly ordered: Idle -> Cancelled -> Draining -> Finalized. Any out-of-order transition attempt returns Err with stable code CANCEL_PROTOCOL_VIOLATION.\n4. Drain has a configurable timeout; if in-flight work does not complete within the timeout, drain returns DrainOutcome::TimedOut with a list of still-active work items, and finalize force-drops them with a CANCEL_FORCE_DROP log event.\n5. Double-cancel is idempotent (no error, no state change beyond first cancel).\n6. Every service implementing CancellationProtocol emits structured telemetry: CANCEL_SIGNAL_RECEIVED, DRAIN_STARTED, DRAIN_COMPLETED / DRAIN_TIMED_OUT, FINALIZE_COMPLETED with trace correlation IDs and elapsed-time measurements.\n7. Unit tests verify: (a) happy-path cancel -> drain -> finalize completes cleanly, (b) drain timeout triggers forced finalization, (c) out-of-order transition is rejected, (d) double-cancel is idempotent, (e) new work submitted during drain phase is rejected with WORK_REJECTED_DRAINING.\n8. Integration test: a multi-service orchestration cancels all services concurrently and verifies total drain time is bounded by the maximum individual drain timeout (parallel drain, not serial).",
    "created_at": "2026-02-20T07:36:49.901866673Z",
    "created_by": "ubuntu",
    "description": "Master Plan Source: PLAN_TO_CREATE_FRANKEN_NODE.md — Section 10.11 (FrankenSQLite-Inspired Runtime Systems), cross-ref Section 9G.2, 9J.19\n\n## Why This Exists\n\nEvery long-running product operation in franken_node — migration orchestration, anti-entropy sweeps, trust rotation, bulk replication, rollout state transitions — must be cancellable in a disciplined manner. The naive approach (drop the future / kill the task) leaves resources leaked, obligations unfulfilled, and partial state scattered across services. Enhancement Map 9G.2 mandates cancellation as a strict protocol for all long-running orchestration tasks, implemented as a three-phase sequence: cancel (signal intent to stop), drain (complete in-flight sub-operations, flush buffers, release held resources), and finalize (produce a terminal status record and obligation closure proof). 9J.19 extends this with cancellation-complete protocol discipline, requiring that every cancellation produces a proof that all obligations spawned by the cancelled operation have been accounted for.\n\nThis bead adopts the canonical cancel-drain-finalize protocol from 10.15 (bd-1cs7) into franken_node's product service layer, providing a `CancellableTask` trait and runtime support that ensures every product service's long-running operations implement the full three-phase cancellation protocol.\n\n## What This Must Do\n\n1. Define a `CancellableTask` trait with three required methods: `on_cancel(&mut self)` (enter drain phase), `on_drain_complete(&mut self) -> DrainResult` (signal drain completion with status), and `on_finalize(&mut self) -> FinalizeRecord` (produce terminal status and obligation closure proof).\n2. Implement a `CancellationRuntime` that manages the lifecycle of cancellable tasks: accepts cancel signals, enforces drain timeout, and calls finalize regardless of drain outcome.\n3. Enforce drain timeout: if `on_drain_complete` is not signalled within a configurable deadline after `on_cancel`, the runtime force-transitions to finalize with a `DrainTimeout` status, ensuring the system never hangs waiting for a stalled drain.\n4. Produce obligation closure proofs on finalize: the `FinalizeRecord` must enumerate every obligation spawned by the task and its terminal state (fulfilled, compensated, or force-closed).\n5. Integrate with the scheduler lane system (bd-lus): cancellation of a task immediately releases its lane slot and bulkhead permit during the cancel phase (not deferred to finalize).\n6. Ensure `CancellableTask` implementations are verified at registration time: a task that does not implement all three methods is rejected with a clear diagnostic.\n\n## Context from Enhancement Maps\n\n- 9G.2: \"Cancellation as a strict protocol for all long-running orchestration tasks\"\n- 9J.19: \"Cancellation-complete protocol discipline with obligation closure proofs\"\n- Architecture invariant #3 (8.5): Cancellation protocol semantics — cancellation is a first-class protocol, not an afterthought.\n- Architecture invariant #4 (8.5): Two-phase effects — drain phase must complete two-phase effects before finalize.\n- Architecture invariant #8 (8.5): Evidence-by-default — finalize records are evidence and must be persisted.\n\n## Dependencies\n\n- Upstream: bd-1cs7 (10.15 cancel-drain-finalize protocol implementation), bd-1n5p (10.15 obligation-tracked channels — for obligation closure proof generation)\n- Downstream: bd-lus (scheduler lanes release slots on cancel), bd-2ah (obligation channels integrate with cancellation for closure proofs), bd-24k (bounded masking defers cancel signals), bd-390 (anti-entropy reconciliation is cancellable), bd-3hw (saga orchestrator cancellation triggers compensation), bd-93k (checkpoint placement is cancel-aware), bd-1jpo (10.11 section-wide verification gate)\n\n## Acceptance Criteria\n\n1. Every long-running product operation (migration, anti-entropy, trust rotation, rollout, replication) implements `CancellableTask` — verified by startup-time registration check.\n2. Cancel signal transitions a running task to drain phase within 1 event-loop tick; the task's lane slot is released immediately.\n3. Drain timeout enforcement: a task whose drain exceeds the configured deadline (default 5 seconds) is force-transitioned to finalize with `DrainTimeout` status.\n4. `FinalizeRecord` includes: task_id, cancel_reason, drain_status (completed/timed_out), obligation_closure_proof (list of obligation IDs and terminal states), and wall-clock timestamps for each phase transition.\n5. Obligation closure proof is complete: every obligation spawned by the task appears in the proof with a terminal state. A missing obligation causes a `ClosureProofIncomplete` alert.\n6. A task that is not cancelled completes normally and produces a `FinalizeRecord` with `cancel_reason: None` (the protocol applies to all task completions, not just cancellations).\n7. Nested cancellation: a parent task cancellation propagates to child tasks, and the parent's finalize waits for all children's finalize records.\n8. Verification evidence JSON includes tasks_cancelled, tasks_drain_completed, tasks_drain_timed_out, closure_proofs_generated, closure_proofs_complete, and avg_drain_duration_ms fields.\n\n## Testing & Logging Requirements\n\n- Unit tests: (a) CancellableTask lifecycle: create -> run -> cancel -> drain -> finalize; (b) Drain timeout enforcement; (c) FinalizeRecord completeness; (d) Lane slot release timing on cancel; (e) Normal completion (no cancel) still produces FinalizeRecord.\n- Integration tests: (a) Migration orchestration cancel mid-flight with obligation closure; (b) Anti-entropy sweep cancel with partial progress safely abandoned; (c) Nested task cancellation propagation (parent -> 3 children); (d) Cancel during two-phase flow prepare — verify rollback and closure proof.\n- Adversarial tests: (a) Drain handler that panics — verify finalize still executes with error status; (b) Cancel signal sent to already-finalizing task — verify idempotent handling; (c) 100 concurrent cancellations — verify no resource leaks; (d) Cancel with no obligations — verify empty but valid closure proof.\n- Structured logs: Events use stable codes (FN-CX-001 through FN-CX-010), include `task_id`, `trace_id`, `phase` (cancel/drain/finalize), `drain_status`, `obligations_count`. JSON-formatted.\n\n## Expected Artifacts\n\n- docs/specs/section_10_11/bd-7om_contract.md\n- crates/franken-node/src/runtime/cancellation.rs (or equivalent module path)\n- crates/franken-node/src/runtime/cancellable_task.rs (trait definition + registration)\n- scripts/check_cancellation_protocol.py (with --json flag and self_test())\n- tests/test_check_cancellation_protocol.py\n- artifacts/section_10_11/bd-7om/verification_evidence.json\n- artifacts/section_10_11/bd-7om/verification_summary.md",
    "id": "bd-7om",
    "issue_type": "task",
    "notes": "Plan-space QA addendum (2026-02-20):\n1) Preserve full canonical-plan scope; no feature compression or silent omission is allowed.\n2) Completion requires comprehensive verification coverage appropriate to scope: unit tests, integration tests, and E2E scripts/workflows with detailed structured logging (stable event/error codes + trace correlation IDs).\n3) Completion requires reproducible evidence artifacts (machine-readable + human-readable) that allow independent replay and root-cause triage.\n4) Any implementation PR for this bead must include explicit links to the above test/logging artifacts.",
    "priority": 2,
    "status": "open",
    "title": "[10.11] Adopt canonical cancel -> drain -> finalize protocol contracts (from `10.15`) for product services.",
    "updated_at": "2026-02-20T17:09:42.243177974Z"
  },
  {
    "acceptance_criteria": "AC for bd-2ah:\n1. All critical flows adopt obligation-tracked two-phase channels from 10.15: Phase 1 (Prepare) reserves resources and returns an ObligationToken; Phase 2 (Commit/Rollback) consumes the token to finalize or release.\n2. An ObligationToken is a linear type (must be consumed exactly once); dropping an unconsumed token triggers a LEAKED_OBLIGATION panic in debug mode and a structured error log + forced rollback in release mode.\n3. The ObligationChannel<T> type enforces the two-phase contract: prepare(payload) -> Result<ObligationToken>, commit(token) -> Result<T>, rollback(token) -> Result<()>.\n4. Obligation tokens carry a monotonic sequence number and creation timestamp; tokens from a previous epoch (see bd-2gr) are automatically rejected with STALE_OBLIGATION_EPOCH.\n5. A configurable obligation timeout ensures that prepare-without-commit/rollback is detected: if a token is neither committed nor rolled back within the timeout, a background reaper logs OBLIGATION_TIMEOUT and forces rollback.\n6. The channel tracks outstanding obligation count as a gauge metric; the gauge must return to zero after all flows complete (verified in integration tests).\n7. Unit tests verify: (a) prepare -> commit round-trip succeeds, (b) prepare -> rollback releases resources, (c) dropped token triggers leak detection, (d) stale-epoch token is rejected, (e) timeout triggers forced rollback, (f) double-commit on same token returns OBLIGATION_ALREADY_CONSUMED.\n8. Structured log events: OBLIGATION_PREPARE / OBLIGATION_COMMIT / OBLIGATION_ROLLBACK / OBLIGATION_TIMEOUT / LEAKED_OBLIGATION with channel name, sequence number, and trace correlation ID.",
    "created_at": "2026-02-20T07:36:50.060962999Z",
    "created_by": "ubuntu",
    "description": "Master Plan Source: PLAN_TO_CREATE_FRANKEN_NODE.md — Section 10.11 (FrankenSQLite-Inspired Runtime Systems), cross-ref Section 9G.3, 9J.19\n\n## Why This Exists\n\nCritical product flows in franken_node — publish-then-promote, rollback-then-notify, migration-commit-then-cleanup — require atomicity guarantees that simple fire-and-forget messaging cannot provide. If the publish succeeds but the promote notification is lost, the system enters an inconsistent state where a trust artifact is stored but not visible. Enhancement Map 9G.3 mandates obligation-tracked two-phase workflows for critical publish/rollback paths, where each message in a workflow carries a tracked obligation that must be explicitly fulfilled or compensated, and the system can audit at any time which obligations are outstanding. 9J.19 extends this with cancellation-complete protocol discipline, requiring that even cancelled workflows produce obligation closure proofs demonstrating that no obligations were silently dropped.\n\nThis bead adopts the canonical obligation-tracked two-phase channel contracts from 10.15 (bd-1n5p obligation channels) into franken_node's product service layer, replacing ad hoc messaging in critical flows with channels where every sent message creates a tracked obligation, the receiver must acknowledge or reject, and the system maintains an obligation ledger for auditability.\n\n## What This Must Do\n\n1. Implement an `ObligationChannel<T>` abstraction that wraps inter-service communication for critical flows, where every `send()` creates a tracked obligation with a unique obligation ID, deadline, and originating trace context.\n2. The receiver must explicitly `fulfill(obligation_id)` or `reject(obligation_id, reason)` — if neither occurs before the deadline, the channel emits an `ObligationTimeout` event and triggers the configured timeout policy (retry, compensate, or escalate).\n3. Maintain an `ObligationLedger` that tracks all outstanding obligations, their creation time, deadline, and current status — queryable for operational dashboards and audit.\n4. On cancellation of a workflow that has outstanding obligations, produce an obligation closure proof: a signed record listing each obligation and its terminal state (fulfilled, rejected, compensated, or cancelled-with-reason).\n5. Integrate with the append-only decision stream (per 9G.9): all obligation state transitions (created, fulfilled, rejected, timed-out, cancelled) are recorded as immutable events.\n6. Provide a `TwoPhaseFlow` builder that composes obligation channels into multi-step workflows with explicit prepare and commit phases, where prepare can be rolled back atomically.\n\n## Context from Enhancement Maps\n\n- 9G.3: \"Obligation-tracked two-phase workflows for critical publish/rollback paths\"\n- 9J.19: \"Cancellation-complete protocol discipline with obligation closure proofs\"\n- Architecture invariant #4 (8.5): Two-phase effects — critical state changes must go through prepare/commit.\n- Architecture invariant #3 (8.5): Cancellation protocol semantics — cancelled workflows must produce closure proofs.\n- Architecture invariant #8 (8.5): Evidence-by-default — obligation state transitions are evidence and must be recorded.\n\n## Dependencies\n\n- Upstream: bd-1n5p (10.15 obligation-tracked two-phase channels), bd-7om (cancel-drain-finalize protocol for cancellation integration), bd-126h (10.14 append-only marker stream for decision stream recording)\n- Downstream: bd-390 (anti-entropy reconciliation applies records through obligation channels), bd-3hw (saga orchestrator composes with obligation channels), bd-93k (checkpoint placement integrates with obligation tracking), bd-1jpo (10.11 section-wide verification gate)\n\n## Acceptance Criteria\n\n1. Every critical flow (publish-promote, rollback-notify, migration-commit-cleanup) uses `ObligationChannel` instead of direct messaging — verified by code audit gate.\n2. An unfulfilled obligation triggers `ObligationTimeout` event within 1 second of the deadline, with the configured policy (retry/compensate/escalate) executing automatically.\n3. The `ObligationLedger` correctly reports all outstanding obligations with creation time, deadline, and status — verified by querying during a multi-step workflow.\n4. Cancellation of a workflow with 3 outstanding obligations produces a closure proof listing all 3 obligations and their terminal states.\n5. Obligation closure proofs are signed and verifiable; a tampered proof fails verification.\n6. All obligation state transitions appear in the append-only decision stream in causal order.\n7. `TwoPhaseFlow` builder: a prepare phase that succeeds followed by a commit phase that fails triggers automatic rollback of the prepare, verified end-to-end.\n8. Verification evidence JSON includes obligations_created, obligations_fulfilled, obligations_timed_out, obligations_cancelled, closure_proofs_generated, and ledger_query_latency_ms fields.\n\n## Testing & Logging Requirements\n\n- Unit tests: (a) ObligationChannel send creates obligation with correct ID and deadline; (b) fulfill() transitions obligation to fulfilled state; (c) reject() transitions to rejected state; (d) Timeout fires at deadline; (e) Closure proof includes all obligations from a cancelled workflow.\n- Integration tests: (a) Full publish-promote flow through obligation channels with success path; (b) Publish-promote with promote failure triggering compensation; (c) Multi-step TwoPhaseFlow with rollback on commit failure; (d) Obligation ledger query during active workflow returns correct state.\n- Adversarial tests: (a) Double-fulfill of the same obligation — verify idempotent acceptance or rejection; (b) Fulfill after deadline — verify late fulfillment is recorded but does not suppress the timeout event; (c) Cancellation during the prepare phase of a TwoPhaseFlow — verify rollback and closure proof; (d) Obligation ledger under high concurrency (1000 concurrent obligations) — verify no lost obligations.\n- Structured logs: Events use stable codes (FN-OB-001 through FN-OB-012), include `obligation_id`, `trace_id`, `deadline`, `status`, `workflow_id`. JSON-formatted.\n\n## Expected Artifacts\n\n- docs/specs/section_10_11/bd-2ah_contract.md\n- crates/franken-node/src/runtime/obligation_channel.rs (or equivalent module path)\n- crates/franken-node/src/runtime/obligation_ledger.rs\n- crates/franken-node/src/runtime/two_phase_flow.rs\n- scripts/check_obligation_channels.py (with --json flag and self_test())\n- tests/test_check_obligation_channels.py\n- artifacts/section_10_11/bd-2ah/verification_evidence.json\n- artifacts/section_10_11/bd-2ah/verification_summary.md",
    "id": "bd-2ah",
    "issue_type": "task",
    "priority": 2,
    "status": "open",
    "title": "[10.11] Adopt canonical obligation-tracked two-phase channel contracts (from `10.15`) for critical flows.",
    "updated_at": "2026-02-20T17:01:40.922902406Z"
  }
]
