use frankenengine_node::control_plane::audience_token::{
    ActionScope, AudienceBoundToken, TokenChain, TokenId, TokenValidator,
};

#[test]
fn exploit_prefix_replay() {
    let now_ms = 1000;

    // Create Root A
    let root = AudienceBoundToken {
        token_id: TokenId("root".into()),
        issuer: "issuer".into(),
        audience: vec!["ServiceX".into()],
        capabilities: vec![
            ActionScope::Migrate,
            ActionScope::Configure,
            ActionScope::Promote,
        ]
        .into_iter()
        .collect(),
        issued_at: now_ms,
        expires_at: now_ms + 10000,
        nonce: "nonce-A".into(),
        parent_token_hash: None,
        signature: "sig-A".into(),
        max_delegation_depth: 5,
    };

    // Delegate A -> B
    let token_b = AudienceBoundToken {
        token_id: TokenId("B".into()),
        issuer: "issuer".into(),
        audience: vec!["ServiceX".into()],
        capabilities: vec![ActionScope::Migrate, ActionScope::Configure]
            .into_iter()
            .collect(),
        issued_at: now_ms,
        expires_at: now_ms + 10000,
        nonce: "nonce-B".into(),
        parent_token_hash: Some(root.hash()),
        signature: "sig-B".into(),
        max_delegation_depth: 4,
    };

    // Delegate B -> C
    let token_c = AudienceBoundToken {
        token_id: TokenId("C".into()),
        issuer: "issuer".into(),
        audience: vec!["ServiceX".into()],
        capabilities: vec![ActionScope::Migrate].into_iter().collect(),
        issued_at: now_ms,
        expires_at: now_ms + 10000,
        nonce: "nonce-C".into(),
        parent_token_hash: Some(token_b.hash()),
        signature: "sig-C".into(),
        max_delegation_depth: 3,
    };

    let mut chain_abc = TokenChain::new(root.clone()).unwrap();
    chain_abc.append(token_b.clone()).unwrap();
    chain_abc.append(token_c.clone()).unwrap();

    let mut validator = TokenValidator::new(1);

    // Legitimate owner submits A -> B -> C to ServiceX.
    let res = validator.verify_chain(&chain_abc, "ServiceX", now_ms, "trace-1");
    assert!(res.is_ok(), "Legitimate chain should pass");

    // Attacker observes A -> B -> C on the wire, extracts A -> B.
    let mut chain_ab = TokenChain::new(root.clone()).unwrap();
    chain_ab.append(token_b.clone()).unwrap();

    // Attacker submits A -> B to ServiceX!
    let res = validator.verify_chain(&chain_ab, "ServiceX", now_ms, "trace-2");

    // If the vulnerability exists, the attacker's replay of the prefix A -> B succeeds!
    assert!(
        res.is_err(),
        "VULNERABILITY: Attacker successfully replayed chain prefix A -> B!"
    );
}
